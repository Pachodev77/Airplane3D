<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Avión 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .joystick {
            position: absolute;
            width: 120px;
            height: 120px;
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        
        .joystick::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .joystick::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 2px;
            background: rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        
        .joystick-handle {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid #333;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            z-index: 3;
            user-select: none;
        }
        
        .joystick-handle:active {
            cursor: grabbing;
            background: rgba(255, 255, 255, 1);
        }
        
        .joystick-label {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: center;
            white-space: nowrap;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .control-arrows {
            position: absolute;
            color: rgba(255, 255, 255, 0.8);
            font-size: 9px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 2;
        }
        
        .arrow-up { top: 8px; left: 50%; transform: translateX(-50%); }
        .arrow-down { bottom: 8px; left: 50%; transform: translateX(-50%); }
        .arrow-left { left: 8px; top: 50%; transform: translateY(-50%); }
        .arrow-right { right: 8px; top: 50%; transform: translateY(-50%); }
        
        #leftJoystick {
            bottom: 80px;
            left: 40px;
        }
        
        #rightJoystick {
            bottom: 80px;
            right: 40px;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 15px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 18px;
            border-radius: 12px;
            z-index: 100;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .altitude-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 15px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 18px;
            border-radius: 12px;
            z-index: 100;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        
        <div id="leftJoystick" class="joystick">
            <div class="joystick-handle"></div>
            <div class="control-arrows arrow-up">SUBIR</div>
            <div class="control-arrows arrow-down">BAJAR</div>
            <div class="control-arrows arrow-left">◀</div>
            <div class="control-arrows arrow-right">▶</div>
            <div class="joystick-label">ELEVACIÓN</div>
        </div>
        
        <div id="rightJoystick" class="joystick">
            <div class="joystick-handle"></div>
            <div class="control-arrows arrow-up">+POTENCIA</div>
            <div class="control-arrows arrow-down">-POTENCIA</div>
            <div class="control-arrows arrow-left">◀ GIRO</div>
            <div class="control-arrows arrow-right">GIRO ▶</div>
            <div class="joystick-label">POTENCIA Y DIRECCIÓN</div>
        </div>
        
        <div class="info-panel">
            <div>VELOCIDAD: <span id="speedValue">0</span> km/h</div>
            <div>POTENCIA: <span id="thrustValue">0</span>%</div>
            <div>ESTADO: <span id="flightStatus">PARADO</span></div>
        </div>
        
        <div class="altitude-panel">
            <div>ALTURA: <span id="altitudeValue">0</span>m</div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <!-- World Layout Configuration will be loaded after Three.js -->

    <script>
        // World configuration
        const worldConfig = {
            // World dimensions
            size: 10000,  // World size (radius)
            
            // Urban areas (cities and towns)
            urbanAreas: [
                // Main cities
                { x: -3000, z: -2000, radius: 1200, type: 'city', name: 'Ciudad Norte' },
                { x: 2500, z: 1500, radius: 1000, type: 'city', name: 'Ciudad Sur' },
                
                // Smaller towns
                { x: -1000, z: 3000, radius: 600, type: 'town', name: 'Pueblo del Este' },
                { x: 3500, z: -2500, radius: 700, type: 'town', name: 'Pueblo Oeste' },
                { x: -3500, z: 1000, radius: 500, type: 'town', name: 'Villa Norte' },
                { x: 2000, z: 3500, radius: 550, type: 'town', name: 'Villa Sur' }
            ],
            
            // Rivers (flowing from high to low elevation)
            rivers: [
                {
                    name: 'Río Norte',
                    points: [
                        { x: -4500, z: -4000, width: 60 },
                        { x: -3000, z: -3500, width: 70 },
                        { x: -1500, z: -3000, width: 80 },
                        { x: 0, z: -2000, width: 90 },
                        { x: 2000, z: -1000, width: 100 },
                        { x: 4000, z: 0, width: 110 },
                        { x: 5000, z: 2000, width: 120 }
                    ]
                },
                {
                    name: 'Río Sur',
                    points: [
                        { x: 4000, z: -4500, width: 50 },
                        { x: 2000, z: -3500, width: 60 },
                        { x: 0, z: -2500, width: 70 },
                        { x: -1500, z: -1500, width: 80 },
                        { x: -2000, z: 0, width: 90 },
                        { x: -2500, z: 2000, width: 100 },
                        { x: -3000, z: 4000, width: 110 }
                    ]
                }
            ],
            
            // Lakes (in natural depressions)
            lakes: [
                { x: -2000, z: 2500, radius: 500, name: 'Lago Esmeralda' },
                { x: 3000, z: -1000, radius: 400, name: 'Lago Azul' },
                { x: -3500, z: -1000, radius: 300, name: 'Laguna Norte' },
                { x: 4000, z: 3000, radius: 600, name: 'Laguna del Sur' }
            ],
            
            // Forests (around water sources and in non-arable land)
            forests: [
                { x: -3500, z: -3500, radius: 1200, density: 0.8, name: 'Bosque del Norte' },
                { x: 4000, z: 3000, radius: 1500, density: 0.9, name: 'Bosque del Sur' },
                { x: 0, z: 4000, radius: 1000, density: 0.7, name: 'Bosque del Este' },
                { x: 4500, z: -3500, radius: 800, density: 0.6, name: 'Bosque del Oeste' }
            ],
            
            // Farmland (in flat areas between cities)
            farmlands: [
                { x: 0, z: 0, width: 2000, height: 1500, rotation: Math.PI/4 },
                { x: -2000, z: -2000, width: 1800, height: 1200, rotation: -Math.PI/6 },
                { x: 2000, z: 2000, width: 1600, height: 1400, rotation: Math.PI/8 }
            ],
            
            // Road network configuration
            roads: {
                // Highways (connect major cities)
                highways: [
                    { from: 'Ciudad Norte', to: 'Ciudad Sur', lanes: 4, speedLimit: 120 },
                    { from: 'Ciudad Norte', to: 'Pueblo del Este', lanes: 2, speedLimit: 90 },
                    { from: 'Ciudad Sur', to: 'Pueblo Oeste', lanes: 2, speedLimit: 90 },
                    { from: 'Pueblo del Este', to: 'Villa Sur', lanes: 2, speedLimit: 90 },
                    { from: 'Pueblo Oeste', to: 'Villa Norte', lanes: 2, speedLimit: 90 }
                ],
                
                // Local roads (connect towns and villages)
                localRoads: [
                    // Roads around Ciudad Norte
                    { type: 'ring', center: 'Ciudad Norte', radius: 800, lanes: 2 },
                    { type: 'radial', center: 'Ciudad Norte', angle: 0, length: 1000, lanes: 2 },
                    { type: 'radial', center: 'Ciudad Norte', angle: Math.PI/2, length: 1000, lanes: 2 },
                    
                    // Roads around Ciudad Sur
                    { type: 'ring', center: 'Ciudad Sur', radius: 700, lanes: 2 },
                    { type: 'radial', center: 'Ciudad Sur', angle: Math.PI, length: 1000, lanes: 2 },
                    { type: 'radial', center: 'Ciudad Sur', angle: -Math.PI/2, length: 1000, lanes: 2 }
                ]
            },
            
            // Get urban area by name
            getUrbanArea: function(name) {
                return this.urbanAreas.find(area => area.name === name);
            },
            
            // Check if a point is in any urban area
            isInUrbanArea: function(x, z) {
                return this.urbanAreas.some(area => {
                    const dx = x - area.x;
                    const dz = z - area.z;
                    return Math.sqrt(dx * dx + dz * dz) <= area.radius;
                });
            },
            
            // Check if a point is in water
            isInWater: function(x, z) {
                // Check rivers
                for (const river of this.rivers) {
                    for (let i = 0; i < river.points.length - 1; i++) {
                        const p1 = river.points[i];
                        const p2 = river.points[i + 1];
                        const width = (p1.width + p2.width) / 2;
                        
                        if (this.pointNearLine(x, z, p1.x, p1.z, p2.x, p2.z, width)) {
                            return true;
                        }
                    }
                }
                
                // Check lakes
                for (const lake of this.lakes) {
                    const dx = x - lake.x;
                    const dz = z - lake.z;
                    if (Math.sqrt(dx * dx + dz * dz) <= lake.radius) {
                        return true;
                    }
                }
                
                return false;
            },
            
            // Helper function to check if a point is near a line segment
            pointNearLine: function(px, pz, x1, z1, x2, z2, maxDistance) {
                // Vector from line start to end
                const lineVec = { x: x2 - x1, z: z2 - z1 };
                const lineLength = Math.sqrt(lineVec.x * lineVec.x + lineVec.z * lineVec.z);
                
                // Normalize line vector
                const lineDir = { x: lineVec.x / lineLength, z: lineVec.z / lineLength };
                
                // Vector from line start to point
                const pointVec = { x: px - x1, z: pz - z1 };
                
                // Project point onto line
                const projLength = pointVec.x * lineDir.x + pointVec.z * lineDir.z;
                
                // Find closest point on line segment
                let closest;
                if (projLength < 0) {
                    closest = { x: x1, z: z1 }; // Beyond line start
                } else if (projLength > lineLength) {
                    closest = { x: x2, z: z2 }; // Beyond line end
                } else {
                    closest = {
                        x: x1 + lineDir.x * projLength,
                        z: z1 + lineDir.z * projLength
                    };
                }
                
                // Distance from point to closest point on line
                const dx = px - closest.x;
                const dz = pz - closest.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                return distance <= maxDistance;
            },
            
            // Get the biome at a specific point
            getBiomeAt: function(x, z) {
                // Check if in water
                if (this.isInWater(x, z)) {
                    return 'water';
                }
                
                // Check urban areas
                if (this.isInUrbanArea(x, z)) {
                    return 'urban';
                }
                
                // Check forests
                for (const forest of this.forests) {
                    const dx = x - forest.x;
                    const dz = z - forest.z;
                    if (Math.sqrt(dx * dx + dz * dz) <= forest.radius) {
                        return 'forest';
                    }
                }
                
                // Default to plains
                return 'plains';
            },
            
            // Get elevation at a point (simplified)
            getElevation: function(x, z) {
                // Simple implementation - in a real game, you'd use noise functions
                // or a heightmap for more realistic terrain
                
                // Calculate distance to each elevation point and interpolate
                let totalWeight = 0;
                let weightedSum = 0;
                
                const elevationPoints = [
                    { x: -4000, z: -4000, height: 200 },
                    { x: -4000, z: 0, height: 150 },
                    { x: 0, z: -4000, height: 180 },
                    { x: 4000, z: 4000, height: 20 },
                    { x: 0, z: 4000, height: 50 },
                    { x: 4000, z: 0, height: 30 }
                ];
                
                for (const point of elevationPoints) {
                    const dx = x - point.x;
                    const dz = z - point.z;
                    const distanceSq = dx * dx + dz * dz;
                    
                    if (distanceSq < 0.0001) {
                        return point.height; // Exact match
                    }
                    
                    const weight = 1 / distanceSq;
                    weightedSum += point.height * weight;
                    totalWeight += weight;
                }
                
                return weightedSum / totalWeight;
            }
        };

        // Variables globales principales
        let scene, camera, airplane;
        let velocity = { x: 0, y: 0, z: 0 };
        let rotation = { x: 0, y: 0, z: 0 };
        let smoothElevation = 0;  // Initialize smoothElevation
        let smoothRotationY = 0;  // Initialize smoothRotationY
        let smoothBank = 0;      // Initialize smoothBank for banking animation
        let smoothPitch = 0;     // Initialize smoothPitch for pitch animation
        let clouds = [];
        let isOnGround = true;
        let currentThrust = 0;

        // Sistema de joysticks completamente rediseñado
        const joystickState = {
            left: { x: 0, y: 0, active: false, touchId: null },
            right: { x: 0, y: 0, active: false, touchId: null }
        };

        const activeTouches = new Map();
        let leftHandle, rightHandle, leftContainer, rightContainer;

        // Inicializar elementos DOM
        function initDOM() {
            leftContainer = document.getElementById('leftJoystick');
            rightContainer = document.getElementById('rightJoystick');
            leftHandle = leftContainer?.querySelector('.joystick-handle');
            rightHandle = rightContainer?.querySelector('.joystick-handle');
        }

        // Sistema de joysticks corregido y consistente
        function initJoystickSystem() {
            initDOM();

            function updateJoystickVisual(side, deltaX, deltaY) {
                const maxRadius = 35;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > maxRadius) {
                    deltaX = (deltaX / distance) * maxRadius;
                    deltaY = (deltaY / distance) * maxRadius;
                }
                
                joystickState[side].x = deltaX / maxRadius;
                joystickState[side].y = -deltaY / maxRadius;
                
                const handle = side === 'left' ? leftHandle : rightHandle;
                if (handle) {
                    handle.style.transform = `translate(-50%, -50%) translate(${deltaX}px, ${deltaY}px)`;
                    handle.style.background = 'rgba(255, 255, 255, 1)';
                    handle.style.borderColor = '#0066cc';
                }
            }

            function resetJoystick(side) {
                joystickState[side].x = 0;
                joystickState[side].y = 0;
                joystickState[side].active = false;
                joystickState[side].touchId = null;
                
                const handle = side === 'left' ? leftHandle : rightHandle;
                if (handle) {
                    handle.style.transform = 'translate(-50%, -50%)';
                    handle.style.background = 'rgba(255, 255, 255, 0.95)';
                    handle.style.borderColor = '#333';
                }
            }

            function getJoystickFromPoint(x, y) {
                const leftRect = leftContainer?.getBoundingClientRect();
                const rightRect = rightContainer?.getBoundingClientRect();
                
                if (leftRect) {
                    const leftDist = Math.sqrt(
                        Math.pow(x - (leftRect.left + leftRect.width/2), 2) + 
                        Math.pow(y - (leftRect.top + leftRect.height/2), 2)
                    );
                    if (leftDist <= leftRect.width/2) return 'left';
                }
                
                if (rightRect) {
                    const rightDist = Math.sqrt(
                        Math.pow(x - (rightRect.left + rightRect.width/2), 2) + 
                        Math.pow(y - (rightRect.top + rightRect.height/2), 2)
                    );
                    if (rightDist <= rightRect.width/2) return 'right';
                }
                
                return null;
            }

            // Touch Events - Completamente reescrito
            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                for (let touch of e.touches) {
                    if (activeTouches.has(touch.identifier)) continue;
                    
                    const side = getJoystickFromPoint(touch.clientX, touch.clientY);
                    if (!side || joystickState[side].active) continue;
                    
                    joystickState[side].active = true;
                    joystickState[side].touchId = touch.identifier;
                    activeTouches.set(touch.identifier, side);
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let touch of e.touches) {
                    const side = activeTouches.get(touch.identifier);
                    if (!side) continue;
                    
                    const container = side === 'left' ? leftContainer : rightContainer;
                    const rect = container?.getBoundingClientRect();
                    if (!rect) continue;
                    
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const deltaX = touch.clientX - centerX;
                    const deltaY = touch.clientY - centerY;
                    
                    updateJoystickVisual(side, deltaX, deltaY);
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                // Encontrar touches que terminaron
                const endedTouches = [];
                activeTouches.forEach((side, touchId) => {
                    let stillActive = false;
                    for (let touch of e.touches) {
                        if (touch.identifier === touchId) {
                            stillActive = true;
                            break;
                        }
                    }
                    if (!stillActive) {
                        endedTouches.push({ touchId, side });
                    }
                });
                
                // Resetear joysticks terminados
                endedTouches.forEach(({ touchId, side }) => {
                    activeTouches.delete(touchId);
                    resetJoystick(side);
                });
            }, { passive: false });

            // Mouse Events para desktop
            let mouseJoystick = null;
            
            document.addEventListener('mousedown', (e) => {
                const side = getJoystickFromPoint(e.clientX, e.clientY);
                if (!side || joystickState[side].active) return;
                
                mouseJoystick = side;
                joystickState[side].active = true;
                joystickState[side].touchId = 'mouse';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!mouseJoystick) return;
                
                const container = mouseJoystick === 'left' ? leftContainer : rightContainer;
                const rect = container?.getBoundingClientRect();
                if (!rect) return;
                
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const deltaX = e.clientX - centerX;
                const deltaY = e.clientY - centerY;
                
                updateJoystickVisual(mouseJoystick, deltaX, deltaY);
            });

            document.addEventListener('mouseup', () => {
                if (mouseJoystick) {
                    resetJoystick(mouseJoystick);
                    mouseJoystick = null;
                }
            });
        }

        // Crear avión
        function createAirplane() {
            airplane = new THREE.Group();
            
            // Fuselaje principal
            const fuselageGeometry = new THREE.CylinderGeometry(0.4, 0.9, 7, 10);
            const fuselageMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            fuselage.rotation.x = Math.PI / 2;
            airplane.add(fuselage);
            
            // Alas principales
            const wingGeometry = new THREE.BoxGeometry(14, 0.4, 2.5);
            const wingMaterial = new THREE.MeshLambertMaterial({ color: 0x1E90FF });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.set(0, 0, -0.8);
            airplane.add(wings);
            
            // Cola vertical
            const tailGeometry = new THREE.BoxGeometry(2, 4, 0.3);
            const tail = new THREE.Mesh(tailGeometry, wingMaterial);
            tail.position.set(0, 2, -3);
            airplane.add(tail);
            
            // Cola horizontal
            const hTailGeometry = new THREE.BoxGeometry(5, 0.3, 1.2);
            const hTail = new THREE.Mesh(hTailGeometry, wingMaterial);
            hTail.position.set(0, 0, -3);
            airplane.add(hTail);
            
            // Hélice
            const propGeometry = new THREE.BoxGeometry(0.15, 5, 0.15);
            const propMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const propeller = new THREE.Mesh(propGeometry, propMaterial);
            propeller.position.set(0, 0, 3.2);
            propeller.name = 'propeller';
            airplane.add(propeller);
            
            // Posición inicial en la pista
            airplane.position.set(0, -41, 0);
            airplane.rotation.y = 0;
            scene.add(airplane);
        }

        // World configuration is now defined inline
        
        // Create the world with optimized ground and fixed z-fighting
        function createWorld() {
            // Clear existing ground objects if any
            const groundObjects = ['ground', 'runway', 'roads', 'water'];
            scene.children = scene.children.filter(child => !groundObjects.includes(child.userData.type));
            
            // 1. Create base ground plane (lowest layer)
            const groundGeometry = new THREE.PlaneGeometry(worldConfig.size * 2, worldConfig.size * 2, 1, 1);
            
            // Simple color material for better performance
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a7c59, // Dark green
                roughness: 1.0,
                metalness: 0.0,
                side: THREE.DoubleSide
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -50;  // Slightly below other objects
            ground.receiveShadow = true;
            ground.userData.type = 'ground';
            scene.add(ground);
            
            // 2. Create a grid helper for better spatial reference (temporary, can be removed later)
            const gridHelper = new THREE.GridHelper(worldConfig.size * 2, 100, 0x555555, 0x333333);
            gridHelper.position.y = -49.9;  // Just above the ground
            gridHelper.userData.type = 'grid';
            scene.add(gridHelper);
            
            // 3. Create runway with proper layering
            createRunway(0, 0, 200, 3000);
            
            // 4. Create water bodies next
            createWaterBodies();
            
            // 5. Create terrain features (hills, etc.)
            createTerrainFeatures();
            
            // 6. Create roads and paths
            createRoadNetwork();
            
            // 7. Add urban areas
            createUrbanAreas();
            
            // 8. Add vegetation and natural features
            createNaturalFeatures();
            createScatteredVegetation();
            
            // 9. Add clouds (skybox would be better for performance)
            createClouds();
            
            console.log('World created with optimized ground and fixed z-fighting');
        }
        
        // Create terrain features like hills and valleys
        function createTerrainFeatures() {
            // Create a few large hills/mountains
            const hillCount = 5;
            const hillGeometry = new THREE.SphereGeometry(1, 32, 32);
            const hillMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a5f0b,
                roughness: 1.0,
                flatShading: true
            });
            
            for (let i = 0; i < hillCount; i++) {
                const size = 500 + Math.random() * 1000;
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                
                // Position hills away from the center
                const angle = (i / hillCount) * Math.PI * 2;
                const distance = 2000 + Math.random() * 3000;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                hill.scale.set(size, size * 0.3, size);
                hill.position.set(x, -50 + (size * 0.3) / 2, z);
                hill.userData.type = 'terrain';
                
                // Make sure hills don't interfere with the runway area
                if (Math.abs(x) > 500 || Math.abs(z) > 500) {
                    scene.add(hill);
                }
            }
            
            // Add some smaller terrain variations
            const detailCount = 20;
            const detailGeometry = new THREE.SphereGeometry(1, 16, 16);
            
            for (let i = 0; i < detailCount; i++) {
                const size = 50 + Math.random() * 200;
                const detail = new THREE.Mesh(detailGeometry, hillMaterial);
                
                const x = (Math.random() - 0.5) * worldConfig.size * 1.5;
                const z = (Math.random() - 0.5) * worldConfig.size * 1.5;
                
                // Skip if too close to center (runway area)
                if (Math.abs(x) < 500 && Math.abs(z) < 500) continue;
                
                detail.scale.set(size, size * 0.2, size);
                detail.position.set(x, -50 + (size * 0.2) / 2, z);
                detail.userData.type = 'terrain_detail';
                scene.add(detail);
            }
        }
        
        // Create a runway with proper markings and z-fighting prevention
        function createRunway(x, z, width, length) {
            // Create runway surface with a small offset to prevent z-fighting
            const runwayGeometry = new THREE.PlaneGeometry(width, length);
            
            // Create runway material with higher resolution texture
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;  // Higher resolution for better quality
            canvas.height = 4096;
            
            // Dark gray background
            context.fillStyle = '#444444';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center line
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 2;
            context.setLineDash([40, 20]);
            context.beginPath();
            context.moveTo(canvas.width / 2, 0);
            context.lineTo(canvas.width / 2, canvas.height);
            context.stroke();
            
            // Edge lines
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 4;
            context.setLineDash([]);
            
            // Left edge
            context.beginPath();
            context.moveTo(10, 0);
            context.lineTo(10, canvas.height);
            context.stroke();
            
            // Right edge
            context.beginPath();
            context.moveTo(canvas.width - 10, 0);
            context.lineTo(canvas.width - 10, canvas.height);
            context.stroke();
            
            // Threshold bars at both ends
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = 2;
            
            // Bottom threshold
            context.beginPath();
            context.moveTo(30, 50);
            context.lineTo(canvas.width - 30, 50);
            context.stroke();
            
            // Top threshold
            context.beginPath();
            context.moveTo(30, canvas.height - 50);
            context.lineTo(canvas.width - 30, canvas.height - 50);
            context.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            
            const runwayMaterial = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.5,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            
            // Create a thicker runway to prevent z-fighting
            const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.rotation.x = -Math.PI / 2;
            runway.position.set(x, -49.2, z);  // Slightly above ground to prevent z-fighting
            runway.receiveShadow = true;
            runway.userData.type = 'runway';
            
            // Add a thin border to the runway for better visibility
            const borderGeometry = new THREE.BoxGeometry(width + 10, 1, length + 10);
            const borderMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.0
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.set(x, -49.1, z);
            border.userData.type = 'runway_border';
            
            scene.add(runway);
            scene.add(border);
            
            return runway;
        }
        
        // Create natural features (rivers, lakes, forests, etc.)
        function createNaturalFeatures() {
            // Create rivers
            for (const river of worldConfig.rivers) {
                createRiver(river);
            }
            
            // Create lakes
            for (const lake of worldConfig.lakes) {
                createLake(lake.x, lake.z, lake.radius);
            }
            
            // Create forests
            for (const forest of worldConfig.forests) {
                createForest(forest.x, forest.z, forest.radius);
            }
            
            // Create farmlands
            for (const field of worldConfig.farmlands) {
                createFarmField(field.x, field.z);
            }
            
            // Create scattered vegetation
            createScatteredVegetation();
        }
        
        // Create clouds for the sky
        function createClouds() {
            const cloudGeometry = new THREE.SphereGeometry(1, 8, 8);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });
            
            // Create multiple clouds
            for (let i = 0; i < 15; i++) {
                const cloud = new THREE.Group();
                const cloudParts = 5 + Math.floor(Math.random() * 10);
                
                for (let j = 0; j < cloudParts; j++) {
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    const scale = 10 + Math.random() * 10;
                    cloudPart.scale.set(scale, scale * 0.5, scale * 0.7);
                    cloudPart.position.set(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 30
                    );
                    cloudPart.rotation.y = Math.random() * Math.PI * 2;
                    cloud.add(cloudPart);
                }
                
                // Position clouds in the sky
                cloud.position.set(
                    (Math.random() - 0.5) * 10000,
                    100 + Math.random() * 200,
                    (Math.random() - 0.5) * 10000
                );
                
                // Store cloud reference for animation
                cloud.userData = {
                    speed: 0.05 + Math.random() * 0.1, // Random speed for each cloud
                    direction: new THREE.Vector3(
                        Math.random() * 0.1 - 0.05, // Random X direction
                        0, // No vertical movement
                        Math.random() * 0.1 - 0.05  // Random Z direction
                    ).normalize()
                };
                
                // Add to clouds array for animation
                if (!window.clouds) window.clouds = [];
                window.clouds.push(cloud);
                
                scene.add(cloud);
            }
        }
        
        // Update cloud positions for animation
        function updateClouds() {
            if (!window.clouds || !window.clouds.length) return;
            
            const worldSize = worldConfig.size * 1.5;
            
            window.clouds.forEach(cloud => {
                if (cloud && cloud.userData) {
                    // Move cloud
                    cloud.position.x += cloud.userData.direction.x * cloud.userData.speed;
                    cloud.position.z += cloud.userData.direction.z * cloud.userData.speed;
                    
                    // Wrap around world boundaries
                    if (Math.abs(cloud.position.x) > worldSize) {
                        cloud.position.x = -cloud.position.x * 0.9;
                    }
                    if (Math.abs(cloud.position.z) > worldSize) {
                        cloud.position.z = -cloud.position.z * 0.9;
                    }
                }
            });
        }
        
        // Create urban areas (cities and towns)
        function createUrbanAreas() {
            for (const area of worldConfig.urbanAreas) {
                if (area.type === 'city') {
                    // Provide default values for all parameters to prevent NaN
                    const buildingCount = area.radius || 30; // Default to 30 buildings if radius is not defined
                    const maxHeight = area.maxHeight || 100; // Default max height
                    const spread = area.spread || 500; // Default spread
                    createCity(area.x || 0, area.z || 0, buildingCount, maxHeight, spread);
                } else {
                    createTown(area.x || 0, area.z || 0, area.radius || 10);
                }
            }
            
            // Create clouds
            const cloudParts = 5;
            const cloudGeometry = new THREE.SphereGeometry(1, 8, 8);
            const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            
            for (let i = 0; i < 20; i++) {
                const cloud = new THREE.Group();
                
                for (let j = 0; j < cloudParts; j++) {
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    const scale = Math.random() * 6 + 4;
                    cloudPart.scale.set(scale, scale, scale);
                    cloudPart.position.set(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 20
                    );
                    cloud.add(cloudPart);
                }
                
                cloud.position.set(
                    (Math.random() - 0.5) * 8000,  // Menor rango de distribución
                    Math.random() * 150 + 50,      // Más bajas en el cielo
                    (Math.random() - 0.5) * 8000
                );
                
                clouds.push(cloud);
                scene.add(cloud);
            }
            
            // Create buildings
            createBuildings();
        }

        function createBuildings() {
            // Definir ubicaciones estratégicas cerca de fuentes de agua
            const cityLocations = [
                // Ciudades principales (x, z, buildingCount, maxHeight, spread, nearWater)
                {x: 1500, z: -2000, count: 120, height: 140, spread: 1000, water: true},
                {x: -2000, z: 1800, count: 100, height: 120, spread: 900, water: true},
                {x: 3000, z: 2500, count: 90, height: 100, spread: 800, water: true},
                {x: -3000, z: -1500, count: 80, height: 110, spread: 850, water: true},
                {x: 2000, z: 3500, count: 70, height: 90, spread: 750, water: true}
            ];
            
            // Crear ciudades principales
            cityLocations.forEach(loc => {
                // Ajustar posición para que esté cerca del agua si es necesario
                if (loc.water) {
                    // Añadir variación a la posición para que no estén todas en el mismo lugar
                    const offsetX = (Math.random() - 0.5) * 500;
                    const offsetZ = (Math.random() - 0.5) * 500;
                    createCity(loc.x + offsetX, loc.z + offsetZ, loc.count, loc.height, loc.spread);
                    
                    // Crear un puerto o área costera
                    createPort(loc.x + offsetX, loc.z + offsetZ, loc.spread * 0.4);
                } else {
                    createCity(loc.x, loc.z, loc.count, loc.height, loc.spread);
                }
            });
            
            // Crear ciudades medianas (más pequeñas)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const distance = 3000 + Math.random() * 1000;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance * 0.8; // Aplanar un poco la elipse
                const size = Math.floor(Math.random() * 15) + 20; // 20-35 edificios
                createCity(x, z, size, 40 + Math.random() * 30, 300 + Math.random() * 200);
            }
            
            // Crear pueblos pequeños
            for (let i = 0; i < 25; i++) {
                // Distribuir pueblos más densamente cerca de las carreteras principales
                let x, z;
                if (Math.random() > 0.3) {
                    // 70% de probabilidad de estar cerca de una carretera principal
                    const roadAngle = Math.floor(Math.random() * 4) * (Math.PI / 2);
                    const roadDistance = (Math.random() * 2 - 1) * 1000;
                    x = Math.cos(roadAngle) * roadDistance;
                    z = Math.sin(roadAngle) * roadDistance;
                    // Añadir variación aleatoria
                    x += (Math.random() - 0.5) * 800;
                    z += (Math.random() - 0.5) * 800;
                } else {
                    // 30% de probabilidad de estar en ubicación aleatoria
                    x = (Math.random() - 0.5) * 8000;
                    z = (Math.random() - 0.5) * 8000;
                }
                
                const size = Math.floor(Math.random() * 8) + 5; // 5-13 edificios
                createTown(x, z, size);
                
                // A veces añadir un pequeño lago o estanque cerca del pueblo
                if (Math.random() > 0.7) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 50 + Math.random() * 100;
                    createPond(
                        x + Math.cos(angle) * distance,
                        z + Math.sin(angle) * distance
                    );
                }
            }
            
            // Crear red de carreteras principales
            createRoadNetwork();
            
            // Crear muchísimos más bosques
            for (let i = 0; i < 60; i++) {
                const x = (Math.random() - 0.5) * 11500;
                const z = (Math.random() - 0.5) * 11500;
                const treeCount = Math.random() * 120 + 80;
                createForest(x, z, treeCount);
            }
            
            // Crear campos de cultivo extensos
            for (let i = 0; i < 45; i++) {
                const x = (Math.random() - 0.5) * 11000;
                const z = (Math.random() - 0.5) * 11000;
                createFarmField(x, z);
            }
            
            // Crear parques urbanos
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 8000;
                const z = (Math.random() - 0.5) * 8000;
                createPark(x, z);
            }
            
            // Crear ríos y lagos
            createWaterBodies();
            
            // Agregar vegetación dispersa por todo el mapa
            createScatteredVegetation();
        }

        function createRoadNetwork() {
            // Carreteras principales en una cuadrícula lógica
            const gridSize = 2000; // Distancia entre carreteras principales
            const worldSize = 10000; // Tamaño total del mundo
            
            // Carreteras horizontales (Este-Oeste)
            for (let z = -worldSize/2; z <= worldSize/2; z += gridSize) {
                const width = (z % (gridSize * 2) === 0) ? 40 : 30; // Alternar entre carreteras principales y secundarias
                createHighway(-worldSize/2, z, worldSize, width, 0);
                
                // Añadir carreteras más pequeñas entre las principales
                if (z < worldSize/2) {
                    const smallRoadCount = 3; // Número de carreteras pequeñas entre principales
                    for (let i = 1; i <= smallRoadCount; i++) {
                        const smallZ = z + (i * gridSize) / (smallRoadCount + 1);
                        createHighway(-worldSize/2, smallZ, worldSize, 20, 0);
                    }
                }
            }
            
            // Carreteras verticales (Norte-Sur)
            for (let x = -worldSize/2; x <= worldSize/2; x += gridSize) {
                const width = (x % (gridSize * 2) === 0) ? 40 : 30;
                createHighway(x, -worldSize/2, worldSize, width, Math.PI/2);
                
                // Añadir carreteras más pequeñas entre las principales
                if (x < worldSize/2) {
                    const smallRoadCount = 3;
                    for (let i = 1; i <= smallRoadCount; i++) {
                        const smallX = x + (i * gridSize) / (smallRoadCount + 1);
                        createHighway(smallX, -worldSize/2, worldSize, 20, Math.PI/2);
                    }
                }
            }
            
            // Carreteras urbanas conectando ciudades
            createUrbanRoads();
        }

        function createHighway(x, z, length, width, rotation) {
            // Aumentar ligeramente el ancho para que las carreteras se superpongan correctamente
            const overlapMargin = 0.5; // Pequeño margen para evitar huecos
            
            // Crear la carretera principal
            const roadGeometry = new THREE.PlaneGeometry(length + overlapMargin, width + overlapMargin);
            const roadMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                depthWrite: true
            });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2;
            road.rotation.z = rotation;
            road.position.set(x, -48.5, z);  // Carretera principal más alta
            scene.add(road);
            
            // Líneas divisorias solo en carreteras principales
            if (width >= 30) { // Solo para carreteras anchas (principales)
                const lineSpacing = 50; // Espacio entre líneas
                const lineCount = Math.floor(length / lineSpacing);
                const lineLength = lineSpacing * 0.8; // Longitud de la línea (80% del espacio)
                
                for (let i = 0; i < lineCount; i++) {
                    const lineGeometry = new THREE.PlaneGeometry(lineLength, 2);
                    const lineMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFFFF,
                        depthWrite: false // Evitar problemas de profundidad
                    });
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.rotation.z = rotation;
                    
                    // Posicionar la línea a lo largo de la carretera
                    const linePos = (i / lineCount - 0.5) * length * 0.9; // 90% de la longitud para margen
                    line.position.set(
                        x + Math.cos(rotation + Math.PI/2) * linePos,
                        -48.4, // Ligeramente por encima de la carretera
                        z + Math.sin(rotation + Math.PI/2) * linePos
                    );
                    
                    scene.add(line);
                }
            }
        }

        function createPort(x, z, size) {
            // Crear área del puerto
            const portGeometry = new THREE.PlaneGeometry(size * 2, size * 2);
            const portMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513, // Marrón para el área del puerto
                side: THREE.DoubleSide
            });
            const port = new THREE.Mesh(portGeometry, portMaterial);
            port.rotation.x = -Math.PI / 2;
            port.position.set(x, -48.8, z);
            scene.add(port);
            
            // Añadir muelles
            const dockCount = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < dockCount; i++) {
                const dockGeometry = new THREE.BoxGeometry(100, 5, 20);
                const dockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
                const dock = new THREE.Mesh(dockGeometry, dockMaterial);
                const angle = (i / dockCount) * Math.PI * 2;
                const distance = size * 0.7;
                dock.position.set(
                    x + Math.cos(angle) * distance,
                    -46.5, // Un poco más alto que el agua
                    z + Math.sin(angle) * distance
                );
                dock.rotation.y = -angle + Math.PI/2;
                scene.add(dock);
                
                // Añadir barcos pequeños
                if (Math.random() > 0.3) {
                    const boat = createBoat();
                    boat.position.set(
                        x + Math.cos(angle) * (distance - 30),
                        -48.5,
                        z + Math.sin(angle) * (distance - 30)
                    );
                    boat.rotation.y = -angle;
                    scene.add(boat);
                }
            }
        }
        
        function createBoat() {
            const boat = new THREE.Group();
            
            // Casco del barco
            const hullGeometry = new THREE.CylinderGeometry(5, 10, 30, 8, 1, true);
            hullGeometry.rotateZ(Math.PI / 2);
            const hullMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = 1;
            boat.add(hull);
            
            // Cubierta
            const deckGeometry = new THREE.BoxGeometry(25, 2, 10);
            const deckMaterial = new THREE.MeshLambertMaterial({ color: 0x5D4037 });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.y = 3;
            boat.add(deck);
            
            // Velas
            const sailGeometry = new THREE.PlaneGeometry(15, 20);
            const sailMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5F5F5,
                side: THREE.DoubleSide
            });
            const sail1 = new THREE.Mesh(sailGeometry, sailMaterial);
            sail1.position.set(0, 15, 0);
            boat.add(sail1);
            
            return boat;
        }
        
        function createUrbanRoads() {
            // Obtener ubicaciones de las ciudades principales
            const mainCities = [
                {x: 1500, z: -2000}, 
                {x: -2000, z: 1800}, 
                {x: 3000, z: 2500},
                {x: -3000, z: -1500},
                {x: 2000, z: 3500}
            ];
            
            // Conectar ciudades principales en un anillo
            for (let i = 0; i < mainCities.length; i++) {
                const current = mainCities[i];
                const next = mainCities[(i + 1) % mainCities.length];
                
                // Crear carretera entre ciudades
                const dx = next.x - current.x;
                const dz = next.z - current.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const angle = Math.atan2(dz, dx);
                
                createHighway(
                    current.x + Math.cos(angle) * distance * 0.5,
                    current.z + Math.sin(angle) * distance * 0.5,
                    distance,
                    40, // Ancho de la carretera
                    angle + Math.PI/2 // Rotación correcta
                );
                
                // Añadir rampas de entrada/salida
                const rampLength = 100;
                const rampWidth = 20;
                const rampAngle = angle + Math.PI/4; // Ángulo de 45 grados
                
                createHighway(
                    current.x + Math.cos(rampAngle) * rampLength * 0.5,
                    current.z + Math.sin(rampAngle) * rampLength * 0.5,
                    rampLength,
                    rampWidth,
                    rampAngle + Math.PI/2
                );
            }
            
            // Conectar ciudades principales entre sí
            for (let i = 0; i < mainCities.length; i++) {
                for (let j = i + 1; j < mainCities.length; j++) {
                    if (Math.random() > 0.3) continue; // No conectar todas
                    
                    const cityA = mainCities[i];
                    const cityB = mainCities[j];
                    const dx = cityB.x - cityA.x;
                    const dz = cityB.z - cityA.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    const angle = Math.atan2(dz, dx);
                    
                    createHighway(
                        cityA.x + dx * 0.5,
                        cityA.z + dz * 0.5,
                        distance,
                        30, // Ancho de carretera secundaria
                        angle + Math.PI/2
                    );
                }
            }
        }

        function createFarmField(centerX, centerZ) {
            const fieldSize = Math.random() * 300 + 200;
            const fieldType = Math.floor(Math.random() * 4);
            
            let fieldColor;
            switch(fieldType) {
                case 0: fieldColor = 0x90EE90; break; // Trigo
                case 1: fieldColor = 0x228B22; break; // Maíz
                case 2: fieldColor = 0x9ACD32; break; // Soja
                case 3: fieldColor = 0x32CD32; break; // Pasto
            }
            
            // Campo principal
            const fieldGeometry = new THREE.PlaneGeometry(fieldSize, fieldSize);
            const fieldMaterial = new THREE.MeshLambertMaterial({ color: fieldColor });
            const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
            field.rotation.x = -Math.PI / 2;
            field.position.set(centerX, -49.2, centerZ);
            scene.add(field);
            
            // Surcos del campo
            const rows = Math.floor(fieldSize / 15);
            for (let i = 0; i < rows; i++) {
                const rowGeometry = new THREE.PlaneGeometry(fieldSize * 0.95, 1.5);
                const rowMaterial = new THREE.MeshLambertMaterial({ 
                    color: new THREE.Color(fieldColor).multiplyScalar(0.8) 
                });
                const row = new THREE.Mesh(rowGeometry, rowMaterial);
                row.rotation.x = -Math.PI / 2;
                row.position.set(centerX, -49.1, centerZ + (i - rows/2) * 15);
                scene.add(row);
            }
        }

        function createPark(centerX, centerZ) {
            const parkSize = Math.random() * 150 + 100;
            
            // Base del parque (césped)
            const parkGeometry = new THREE.PlaneGeometry(parkSize, parkSize);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const park = new THREE.Mesh(parkGeometry, parkMaterial);
            park.rotation.x = -Math.PI / 2;
            park.position.set(centerX, -49.2, centerZ);
            scene.add(park);
            
            // Senderos del parque
            const pathWidth = 8;
            const pathGeometry1 = new THREE.PlaneGeometry(parkSize, pathWidth);
            const pathGeometry2 = new THREE.PlaneGeometry(pathWidth, parkSize);
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
            
            const path1 = new THREE.Mesh(pathGeometry1, pathMaterial);
            path1.rotation.x = -Math.PI / 2;
            path1.position.set(centerX, -49.1, centerZ);
            scene.add(path1);
            
            const path2 = new THREE.Mesh(pathGeometry2, pathMaterial);
            path2.rotation.x = -Math.PI / 2;
            path2.position.set(centerX, -49.1, centerZ);
            scene.add(path2);
            
            // Árboles en el parque
            const treeCount = Math.floor(parkSize / 15);
            for (let i = 0; i < treeCount; i++) {
                const treeX = centerX + (Math.random() - 0.5) * parkSize * 0.8;
                const treeZ = centerZ + (Math.random() - 0.5) * parkSize * 0.8;
                const tree = createParkTree();
                tree.position.set(treeX, -49.5, treeZ);
                scene.add(tree);
            }
        }

        function createParkTree() {
            // High detail tree (close-up)
            const createHighDetailTree = () => {
                const treeGroup = new THREE.Group();
                
                // Detailed trunk
                const trunkHeight = Math.random() * 6 + 4;
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, trunkHeight, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                trunk.position.y = trunkHeight / 2;
                treeGroup.add(trunk);
                
                // Detailed crown
                const crownRadius = Math.random() * 3 + 2.5;
                const crown = new THREE.Mesh(
                    new THREE.SphereGeometry(crownRadius, 12, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(0.3, 0.7, 0.4 + Math.random() * 0.2),
                        roughness: 0.9,
                        metalness: 0.1
                    })
                );
                crown.position.y = trunkHeight + crownRadius * 0.3;
                treeGroup.add(crown);
                
                return treeGroup;
            };
            
            // Medium detail tree (mid-range)
            const createMediumDetailTree = () => {
                const treeGroup = new THREE.Group();
                
                // Simpler trunk
                const trunkHeight = Math.random() * 6 + 4;
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, trunkHeight, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.9,
                        metalness: 0.1
                    })
                );
                trunk.position.y = trunkHeight / 2;
                treeGroup.add(trunk);
                
                // Simpler crown
                const crownRadius = Math.random() * 3 + 2.5;
                const crown = new THREE.Mesh(
                    new THREE.SphereGeometry(crownRadius, 8, 6),
                    new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(0.3, 0.7, 0.4 + Math.random() * 0.2),
                        roughness: 0.9,
                        metalness: 0.1
                    })
                );
                crown.position.y = trunkHeight + crownRadius * 0.3;
                treeGroup.add(crown);
                
                return treeGroup;
            };
            
            // Low detail tree (far away)
            const createLowDetailTree = () => {
                const treeGroup = new THREE.Group();
                
                // Very simple tree (just a cone)
                const height = Math.random() * 6 + 6;
                const radius = Math.random() * 2 + 2;
                const tree = new THREE.Mesh(
                    new THREE.ConeGeometry(radius, height, 5, 1),
                    new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(0.3, 0.7, 0.4 + Math.random() * 0.2),
                        roughness: 0.9,
                        metalness: 0.1
                    })
                );
                tree.position.y = height / 2;
                treeGroup.add(tree);
                
                return treeGroup;
            };
            
            // Create LOD object with different detail levels
            const lodTree = new THREE.LOD();
            
            // Add detail levels with transition distances
            lodTree.addLevel(createHighDetailTree(), 0);    // High detail up to 200 units
            lodTree.addLevel(createMediumDetailTree(), 200); // Medium detail up to 500 units
            lodTree.addLevel(createLowDetailTree(), 500);   // Low detail beyond 500 units
            
            return lodTree;
        }

        function createWaterBodies() {
            // Río principal serpenteante
            createRiver();
            
            // Lagos dispersos
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 9000;
                const z = (Math.random() - 0.5) * 9000;
                createLake(x, z);
            }
            
            // Estanques pequeños
            for (let i = 0; i < 15; i++) {
                const x = (Math.random() - 0.5) * 10000;
                const z = (Math.random() - 0.5) * 10000;
                createPond(x, z);
            }
        }

        function createRiver() {
            const segments = 50; // Más segmentos para un flujo más suave
            const riverWidth = 80; // Ancho más consistente
            const points = [];
            
            // Crear puntos de control para una curva suave
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                // Curva más suave y natural con ruido Perlin simple
                const noise = (t) => Math.sin(t * Math.PI * 4) * 0.5 + Math.sin(t * Math.PI * 8) * 0.25;
                
                const x = -4500 + t * 9000 + Math.sin(t * Math.PI * 2) * 1200 * noise(t);
                const z = -3000 * (1 - t) + 3000 * t + Math.cos(t * Math.PI * 3) * 1000 * noise(t + 0.5);
                points.push(new THREE.Vector3(x, -48.9, z));
            }
            
            // Crear una curva suave a través de los puntos
            const curve = new THREE.CatmullRomCurve3(points);
            
            // Crear la geometría del río plana
            const riverShape = new THREE.Shape();
            const riverPoints = curve.getPoints(segments * 2);
            
            riverShape.moveTo(riverPoints[0].x, riverPoints[0].z);
            for (let i = 1; i < riverPoints.length; i++) {
                riverShape.lineTo(riverPoints[i].x, riverPoints[i].z);
            }
            
            // Crear geometría extruida para dar profundidad al río
            const riverGeometry = new THREE.ExtrudeGeometry(riverShape, {
                depth: 5,
                bevelEnabled: false
            });
            riverGeometry.rotateX(-Math.PI / 2);
            
            const riverMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF, // Azul más claro en la superficie
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            river.position.y = -49.8; // Debajo del nivel del suelo
            scene.add(river);
            
            // Crear superficie del río al nivel del suelo
            const riverSurfaceGeometry = new THREE.ShapeGeometry(riverShape);
            riverSurfaceGeometry.rotateX(-Math.PI / 2);
            const riverSurface = new THREE.Mesh(
                riverSurfaceGeometry,
                new THREE.MeshLambertMaterial({
                    color: 0x1E90FF,
                    transparent: true,
                    opacity: 0.8
                })
            );
            riverSurface.position.y = -49.5; // Nivel del suelo
            scene.add(riverSurface);
            
            // Añadir orillas al río (más anchas y con transición suave)
            const bankShape = new THREE.Shape();
            const bankOuterPoints = [];
            
            // Crear puntos para la orilla exterior
            for (let i = 0; i < riverPoints.length; i++) {
                const point = riverPoints[i];
                const nextPoint = riverPoints[(i + 1) % riverPoints.length];
                const dir = new THREE.Vector2(
                    nextPoint.z - point.z,
                    -(nextPoint.x - point.x)
                ).normalize();
                
                // Añadir puntos para la orilla exterior
                const bankWidth = riverWidth * (0.6 + Math.random() * 0.4);
                bankOuterPoints.push(new THREE.Vector2(
                    point.x + dir.x * bankWidth,
                    point.z + dir.y * bankWidth
                ));
            }
            
            // Crear la forma de la orilla
            bankShape.moveTo(bankOuterPoints[0].x, bankOuterPoints[0].y);
            for (let i = 1; i < bankOuterPoints.length; i++) {
                bankShape.lineTo(bankOuterPoints[i].x, bankOuterPoints[i].y);
            }
            
            // Crear la geometría de la orilla
            const bankGeometry = new THREE.ExtrudeGeometry(bankShape, {
                depth: 1,
                bevelEnabled: false
            });
            bankGeometry.rotateX(-Math.PI / 2);
            
            const bankMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513, // Color marrón para la orilla
                side: THREE.DoubleSide
            });
            
            const bank = new THREE.Mesh(bankGeometry, bankMaterial);
            bank.position.y = -49.4; // Justo por encima del agua
            scene.add(bank);
        }

        function createLake(centerX, centerZ) {
            // Crear una forma de lago más orgánica
            const lakeShape = new THREE.Shape();
            const radius = Math.random() * 80 + 60;
            const points = 12 + Math.floor(Math.random() * 8); // 12-20 puntos
            
            // Crear puntos para un contorno irregular
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const variation = 0.7 + Math.random() * 0.6; // 0.7-1.3
                const pointRadius = radius * variation;
                const x = Math.cos(angle) * pointRadius;
                const y = Math.sin(angle) * pointRadius;
                
                if (i === 0) {
                    lakeShape.moveTo(x, y);
                } else {
                    lakeShape.lineTo(x, y);
                }
            }
            
            // Crear geometría extruida para dar profundidad
            const lakeGeometry = new THREE.ExtrudeGeometry(lakeShape, {
                steps: 1,
                depth: 10, // Profundidad del lago
                bevelEnabled: false
            });
            
            // Rotar para que quede horizontal
            lakeGeometry.rotateX(-Math.PI / 2);
            
            // Material con gradiente de color para simular profundidad
            const lakeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF, // Azul más claro en la superficie
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
                depthWrite: true
            });
            
            // Crear el agua del lago (parte inferior)
            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.position.set(centerX, -49.8, centerZ); // Por debajo del nivel del suelo
            scene.add(lake);
            
            // Crear la superficie del lago al nivel del suelo
            const lakeSurfaceGeometry = new THREE.ShapeGeometry(lakeShape);
            lakeSurfaceGeometry.rotateX(-Math.PI / 2);
            const lakeSurface = new THREE.Mesh(
                lakeSurfaceGeometry,
                new THREE.MeshLambertMaterial({
                    color: 0x1E90FF,
                    transparent: true,
                    opacity: 0.7,
                    depthWrite: false
                })
            );
            lakeSurface.position.set(centerX, -49.5, centerZ); // Nivel del suelo
            scene.add(lakeSurface);
            
            // Añadir orilla con textura de arena
            const shoreGeometry = new THREE.ShapeGeometry(lakeShape);
            shoreGeometry.rotateX(-Math.PI / 2);
            const shoreMaterial = new THREE.MeshLambertMaterial({
                color: 0xD2B48C, // Color arena
                side: THREE.DoubleSide,
                depthWrite: true
            });
            const shore = new THREE.Mesh(shoreGeometry, shoreMaterial);
            shore.position.set(centerX, -49.4, centerZ); // Justo por encima del agua
            scene.add(shore);
        }

        function createPond(centerX, centerZ) {
            // Crear una forma de estanque más orgánica
            const pondShape = new THREE.Shape();
            const radius = Math.random() * 20 + 15;
            const points = 8 + Math.floor(Math.random() * 4); // 8-12 puntos
            
            // Crear puntos para un contorno irregular
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const variation = 0.6 + Math.random() * 0.8; // 0.6-1.4 (más irregular)
                const pointRadius = radius * variation;
                const x = Math.cos(angle) * pointRadius;
                const y = Math.sin(angle) * pointRadius;
                
                if (i === 0) {
                    pondShape.moveTo(x, y);
                } else {
                    pondShape.lineTo(x, y);
                }
            }
            
            // Crear el agua del estanque (parte inferior)
            const pondGeometry = new THREE.ExtrudeGeometry(pondShape, {
                steps: 1,
                depth: 5, // Profundidad del estanque
                bevelEnabled: false
            });
            pondGeometry.rotateX(-Math.PI / 2);
            
            const pondMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x5F9EA0, // Verde azulado
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                depthWrite: true
            });
            
            const pond = new THREE.Mesh(pondGeometry, pondMaterial);
            pond.position.set(centerX, -49.8, centerZ); // Por debajo del nivel del suelo
            scene.add(pond);
            
            // Crear la superficie del estanque al nivel del suelo
            const pondSurfaceGeometry = new THREE.ShapeGeometry(pondShape);
            pondSurfaceGeometry.rotateX(-Math.PI / 2);
            const pondSurface = new THREE.Mesh(
                pondSurfaceGeometry,
                new THREE.MeshLambertMaterial({
                    color: 0x5F9EA0,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide,
                    depthWrite: false
                })
            );
            pondSurface.position.set(centerX, -49.5, centerZ); // Nivel del suelo
            scene.add(pondSurface);
            
            // Añadir orilla con vegetación
            const shoreGeometry = new THREE.ShapeGeometry(pondShape);
            shoreGeometry.rotateX(-Math.PI / 2);
            const shoreMaterial = new THREE.MeshLambertMaterial({
                color: 0x8B4513, // Marrón tierra
                side: THREE.DoubleSide,
                depthWrite: true
            });
            const shore = new THREE.Mesh(shoreGeometry, shoreMaterial);
            shore.position.set(centerX, -49.4, centerZ); // Justo por encima del agua
            scene.add(shore);
            
            // Añadir algunos lirios o plantas acuáticas
            const lilyCount = 3 + Math.floor(Math.random() * 5);
            for (let i = 0; i < lilyCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * (radius * 0.7);
                const lilyX = centerX + Math.cos(angle) * distance;
                const lilyZ = centerZ + Math.sin(angle) * distance;
                
                // Planta acuática simple
                const lilyGeometry = new THREE.CircleGeometry(3 + Math.random() * 4, 6);
                const lilyMaterial = new THREE.MeshLambertMaterial({
                    color: 0x228B22, // Verde oscuro
                    side: THREE.DoubleSide,
                    depthWrite: true
                });
                const lily = new THREE.Mesh(lilyGeometry, lilyMaterial);
                lily.rotation.x = -Math.PI / 2;
                lily.position.set(lilyX, -49.3, lilyZ); // Sobre la superficie del agua
                scene.add(lily);
            }
        }

        function createScatteredVegetation() {
            // Arbustos dispersos por todo el mapa
            for (let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 11500;
                const z = (Math.random() - 0.5) * 11500;
                createBush(x, z);
            }
            
            // Grupos de flores silvestres
            for (let i = 0; i < 100; i++) {
                const x = (Math.random() - 0.5) * 11000;
                const z = (Math.random() - 0.5) * 11000;
                createFlowerPatch(x, z);
            }
            
            // Rocas dispersas
            for (let i = 0; i < 80; i++) {
                const x = (Math.random() - 0.5) * 11500;
                const z = (Math.random() - 0.5) * 11500;
                createRock(x, z);
            }
        }

        function createBush(x, z) {
            const bushRadius = Math.random() * 2 + 1;
            const bushHeight = Math.random() * 2 + 1.5;
            const bushGeometry = new THREE.SphereGeometry(bushRadius, 6, 4);
            const bushMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.25 + Math.random() * 0.15, 0.6, 0.3 + Math.random() * 0.3) 
            });
            const bush = new THREE.Mesh(bushGeometry, bushMaterial);
            bush.position.set(x, -49.5 + bushHeight/2, z);
            bush.scale.y = bushHeight / bushRadius;
            scene.add(bush);
        }

        function createFlowerPatch(centerX, centerZ) {
            const patchSize = Math.random() * 15 + 10;
            const flowerColors = [0xFF69B4, 0xFF1493, 0xFFB6C1, 0xFFA500, 0xFF4500, 0x9370DB];
            
            for (let i = 0; i < 8; i++) {
                const x = centerX + (Math.random() - 0.5) * patchSize;
                const z = centerZ + (Math.random() - 0.5) * patchSize;
                
                const flowerGeometry = new THREE.SphereGeometry(0.3, 6, 4);
                const flowerMaterial = new THREE.MeshLambertMaterial({ 
                    color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                });
                const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                flower.position.set(x, -49.2, z);
                scene.add(flower);
            }
        }

        function createRock(x, z) {
            const rockSize = Math.random() * 3 + 2;
            const rockGeometry = new THREE.SphereGeometry(rockSize, 6, 4);
            const rockMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0, 0, 0.3 + Math.random() * 0.3) 
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.set(x, -49.5 + rockSize/2, z);
            rock.scale.set(1, 0.6 + Math.random() * 0.4, 1);
            scene.add(rock);
        }

        function createCity(centerX, centerZ, buildingCount, maxHeight, spread) {
            // Create a grid for building placement to prevent overlap
            const gridSize = 50; // Minimum distance between buildings
            const grid = {};
            
            // Helper function to check if a position is available
            const isPositionAvailable = (x, z, size) => {
                const gridX = Math.round(x / gridSize) * gridSize;
                const gridZ = Math.round(z / gridSize) * gridSize;
                return !grid[`${gridX},${gridZ}`];
            };
            
            // Helper function to mark position as taken
            const markPosition = (x, z, size) => {
                const gridX = Math.round(x / gridSize) * gridSize;
                const gridZ = Math.round(z / gridSize) * gridSize;
                grid[`${gridX},${gridZ}`] = true;
            };
            
            // Create buildings with LOD
            for (let i = 0; i < buildingCount; i++) {
                let x, z, attempts = 0;
                const maxAttempts = 100;
                let positionFound = false;
                
                // Try to find a non-overlapping position
                while (!positionFound && attempts < maxAttempts) {
                    x = centerX + (Math.random() - 0.5) * spread;
                    z = centerZ + (Math.random() - 0.5) * spread;
                    
                    // Skip if too close to center (runway area)
                    if (Math.abs(x) < 600 && Math.abs(z) < 600) {
                        attempts++;
                        continue;
                    }
                    
                    if (isPositionAvailable(x, z, gridSize)) {
                        positionFound = true;
                        markPosition(x, z, gridSize);
                    }
                    attempts++;
                }
                
                if (!positionFound) continue; // Skip if no position found
                
                // Create building with LOD
                const width = Math.random() * 40 + 20;
                const depth = Math.random() * 40 + 20;
                const height = Math.random() * maxHeight + 15;
                
                // Create LOD object
                const buildingLOD = new THREE.LOD();
                
                // High detail (close)
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const buildingMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, Math.random() * 0.4 + 0.3),
                    roughness: 0.7,
                    metalness: 0.3
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                
                // Medium detail (mid-range)
                const mediumGeometry = new THREE.BoxGeometry(width, height, depth, 1, 1, 1);
                const mediumMaterial = new THREE.MeshStandardMaterial({
                    color: buildingMaterial.color,
                    wireframe: false,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const mediumBuilding = new THREE.Mesh(mediumGeometry, mediumMaterial);
                
                // Low detail (far)
                const lowGeometry = new THREE.BoxGeometry(width, height, depth, 1, 1, 1);
                const lowMaterial = new THREE.MeshBasicMaterial({
                    color: buildingMaterial.color,
                    wireframe: false
                });
                const lowBuilding = new THREE.Mesh(lowGeometry, lowMaterial);
                
                // Add levels to LOD
                buildingLOD.addLevel(building, 0);     // High detail up to 500 units
                buildingLOD.addLevel(mediumBuilding, 500);  // Medium detail up to 1000 units
                buildingLOD.addLevel(lowBuilding, 1000);    // Low detail beyond 1000 units
                
                // Position the building
                buildingLOD.position.set(x, -49.5 + height/2, z);
                buildingLOD.castShadow = true;
                buildingLOD.receiveShadow = true;
                buildingLOD.userData.type = 'building';
                
                scene.add(buildingLOD);
            }
        }

        function createTown(centerX, centerZ, houseCount) {
            // Create a grid for house placement to prevent overlap
            const gridSize = 30; // Minimum distance between houses
            const grid = {};
            
            // Helper function to check if a position is available
            const isPositionAvailable = (x, z) => {
                const gridX = Math.round(x / gridSize) * gridSize;
                const gridZ = Math.round(z / gridSize) * gridSize;
                return !grid[`${gridX},${gridZ}`];
            };
            
            // Helper function to mark position as taken
            const markPosition = (x, z) => {
                const gridX = Math.round(x / gridSize) * gridSize;
                const gridZ = Math.round(z / gridSize) * gridSize;
                grid[`${gridX},${gridZ}`] = true;
            };
            
            // Create houses with LOD
            for (let i = 0; i < houseCount; i++) {
                let x, z, attempts = 0;
                const maxAttempts = 100;
                let positionFound = false;
                
                // Try to find a non-overlapping position
                while (!positionFound && attempts < maxAttempts) {
                    x = centerX + (Math.random() - 0.5) * 500; // Larger spread for towns
                    z = centerZ + (Math.random() - 0.5) * 500;
                    
                    // Skip if too close to center (runway area)
                    if (Math.abs(x) < 600 && Math.abs(z) < 600) {
                        attempts++;
                        continue;
                    }
                    
                    if (isPositionAvailable(x, z)) {
                        positionFound = true;
                        markPosition(x, z);
                    }
                    attempts++;
                }
                
                if (!positionFound) continue; // Skip if no position found
                
                const width = Math.random() * 18 + 12;
                const depth = Math.random() * 18 + 12;
                const height = Math.random() * 12 + 8;
                
                const houseColors = [0xDEB887, 0xF0E68C, 0xFFA07A, 0xD3D3D3, 0xF5DEB3, 0xFFB6C1];
                const houseColor = houseColors[Math.floor(Math.random() * houseColors.length)];
                
                // Create LOD object for the house
                const houseLOD = new THREE.LOD();
                
                // High detail (close)
                const houseGeometry = new THREE.BoxGeometry(width, height, depth);
                const houseMaterial = new THREE.MeshStandardMaterial({
                    color: houseColor,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                
                // Medium detail (mid-range)
                const mediumGeometry = new THREE.BoxGeometry(width, height, depth, 1, 1, 1);
                const mediumMaterial = new THREE.MeshStandardMaterial({
                    color: houseColor,
                    wireframe: false,
                    roughness: 0.9,
                    metalness: 0.0
                });
                const mediumHouse = new THREE.Mesh(mediumGeometry, mediumMaterial);
                
                // Low detail (far)
                const lowGeometry = new THREE.BoxGeometry(width, height, depth, 1, 1, 1);
                const lowMaterial = new THREE.MeshBasicMaterial({
                    color: houseColor,
                    wireframe: false
                });
                const lowHouse = new THREE.Mesh(lowGeometry, lowMaterial);
                
                // Add levels to LOD
                houseLOD.addLevel(house, 0);        // High detail up to 300 units
                houseLOD.addLevel(mediumHouse, 300); // Medium detail up to 600 units
                houseLOD.addLevel(lowHouse, 600);    // Low detail beyond 600 units
                
                // Position the house
                houseLOD.position.set(x, -49.5 + height/2, z);
                houseLOD.castShadow = true;
                houseLOD.receiveShadow = true;
                houseLOD.userData.type = 'house';
                
                scene.add(houseLOD);
            }
        }

        function createForest(centerX, centerZ, treeCount) {
            for (let i = 0; i < treeCount; i++) {
                const x = centerX + (Math.random() - 0.5) * 400;
                const z = centerZ + (Math.random() - 0.5) * 400;
                
                // Tronco
                const trunkHeight = Math.random() * 10 + 8;
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 1, trunkHeight, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                trunk.position.set(x, -49.5 + trunkHeight/2, z);
                scene.add(trunk);
                
                // Copa
                const crownRadius = Math.random() * 6 + 4;
                const crown = new THREE.Mesh(
                    new THREE.SphereGeometry(crownRadius, 8, 6),
                    new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.7, 0.3 + Math.random() * 0.3) 
                    })
                );
                crown.position.set(x, -49.5 + trunkHeight + crownRadius * 0.6, z);
                scene.add(crown);
            }
        }

        // Física del avión corregida y suavizada
        function updateAirplane() {
            const leftInput = { x: joystickState.left.x, y: joystickState.left.y };
            const rightInput = { x: joystickState.right.x, y: joystickState.right.y };
            
            // Sistema de potencia gradual
            const thrustInput = rightInput.y;
            if (Math.abs(thrustInput) > 0.05) {
                const thrustRate = isOnGround ? 0.018 : 0.022; // Más gradual
                currentThrust += thrustInput * thrustRate;
                currentThrust = Math.max(0, Math.min(1, currentThrust));
            }
            
            // Aplicar potencia del motor
            const motorForce = 0.12 + (currentThrust * 0.6);
            if (motorForce > 0.15 || !isOnGround) {
                velocity.z += Math.cos(smoothRotationY) * motorForce;
                velocity.x += Math.sin(smoothRotationY) * motorForce;
            }
            
            // Control de elevación GRADUAL
            const targetElevation = leftInput.y * 0.25; // Reducido de 0.4 a 0.25
            smoothElevation += (targetElevation - smoothElevation) * 0.06; // Muy gradual
            velocity.y += smoothElevation;
            
            // Control lateral suave
            velocity.x += leftInput.x * 0.1; // Reducido de 0.15 a 0.1
            
            // Control de dirección SUAVIZADO
            const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
            const baseTurnRate = 0.015; // Reducido de 0.028
            const speedBonus = currentSpeed * 0.012; // Reducido de 0.025
            const targetTurnRate = rightInput.x * (baseTurnRate + speedBonus);
            
            // Suavizar la rotación Y (giros)
            const rotationSmoothFactor = isOnGround ? 0.08 : 0.12; // Más suave en tierra
            smoothRotationY -= targetTurnRate;
            rotation.y += (smoothRotationY - rotation.y) * rotationSmoothFactor;
            
            // Sustentación aerodinámica
            if (currentSpeed > 0.4 && !isOnGround) {
                const lift = Math.min(currentSpeed * 0.018, 0.03); // Reducido ligeramente
                velocity.y += lift;
            }
            
            // Gravedad más suave
            velocity.y -= 0.014; // Reducido de 0.016
            
            // Resistencia del aire optimizada
            const airResistance = isOnGround ? 0.89 : 0.988;
            velocity.x *= airResistance;
            velocity.z *= airResistance;
            velocity.y *= 0.98; // Mejor para elevación gradual
            
            // Efectos visuales SUAVIZADOS
            const targetBank = rightInput.x * 0.5 + leftInput.x * 0.25; // Reducido
            const targetPitch = smoothElevation * 0.6 + (currentThrust * 0.08); // Reducido
            
            // Aplicar suavizado a efectos visuales
            smoothBank += (targetBank - smoothBank) * 0.1; // Muy suave
            smoothPitch += (targetPitch - smoothPitch) * 0.08; // Muy suave
            
            rotation.z = smoothBank;
            rotation.x = smoothPitch;
            
            // Límites de velocidad
            const maxSpeed = 2.8; // Reducido ligeramente
            velocity.x = Math.max(-maxSpeed, Math.min(maxSpeed, velocity.x));
            velocity.z = Math.max(-maxSpeed, Math.min(maxSpeed, velocity.z));
            velocity.y = Math.max(-1.5, Math.min(1.5, velocity.y)); // Reducido
            
            // Actualizar posición
            airplane.position.x += velocity.x;
            airplane.position.y += velocity.y;
            airplane.position.z += velocity.z;
            
            // Lógica de tierra y despegue mejorada
            const groundLevel = -41;
            if (airplane.position.y <= groundLevel) {
                airplane.position.y = groundLevel;
                isOnGround = true;
                velocity.y = Math.max(0, velocity.y);
                
                // Fricción en tierra
                if (currentThrust < 0.25) {
                    velocity.x *= 0.85; // Más fricción
                    velocity.z *= 0.85;
                }
                
                // Condiciones de despegue más estrictas
                if (currentSpeed > 1.2 && smoothElevation > 0.15 && currentThrust > 0.5) {
                    isOnGround = false;
                    velocity.y = 0.2; // Impulso más suave
                }
            } else {
                isOnGround = false;
            }
            
            // Aplicar rotaciones suavizadas con límites más estrictos
            airplane.rotation.y = rotation.y;
            airplane.rotation.x = Math.max(-0.4, Math.min(0.4, rotation.x)); // Reducido
            airplane.rotation.z = Math.max(-0.6, Math.min(0.6, rotation.z)); // Reducido
            
            // Actualizar interfaz
            updateUI(currentSpeed);
            
            // Animar hélices (ambas) más suave
            const leftPropeller = airplane.getObjectByName('leftPropeller');
            const rightPropeller = airplane.getObjectByName('rightPropeller');
            if (leftPropeller) leftPropeller.rotation.z += 0.5 + (currentThrust * 1.5);
            if (rightPropeller) rightPropeller.rotation.z += 0.5 + (currentThrust * 1.5);
        }

        function updateUI(currentSpeed) {
            const speedElement = document.getElementById('speedValue');
            const thrustElement = document.getElementById('thrustValue');
            const altitudeElement = document.getElementById('altitudeValue');
            const statusElement = document.getElementById('flightStatus');
            
            if (speedElement) speedElement.textContent = Math.round(currentSpeed * 85);
            if (thrustElement) thrustElement.textContent = Math.round(currentThrust * 100);
            if (altitudeElement) altitudeElement.textContent = Math.round(airplane.position.y + 50);
            
            if (statusElement) {
                if (isOnGround) {
                    if (currentThrust < 0.15) {
                        statusElement.textContent = 'PARADO';
                        statusElement.style.color = '#ff4444';
                    } else if (currentSpeed > 0.8) {
                        statusElement.textContent = 'DESPEGANDO';
                        statusElement.style.color = '#ffaa00';
                    } else {
                        statusElement.textContent = 'RODANDO';
                        statusElement.style.color = '#88ff88';
                    }
                } else {
                    if (velocity.y > 0.1) {
                        statusElement.textContent = 'ASCENDIENDO';
                        statusElement.style.color = '#44ff44';
                    } else if (velocity.y < -0.1) {
                        statusElement.textContent = 'DESCENDIENDO';
                        statusElement.style.color = '#ff8844';
                    } else {
                        statusElement.textContent = 'VUELO ESTABLE';
                        statusElement.style.color = '#44aaff';
                    }
                }
            }
        }

        // CÁMARA CORREGIDA - Enfoque fijo en la cola del avión
        function updateCamera() {
            // Definir el punto específico de la cola del avión
            const tailPosition = new THREE.Vector3(0, 0, -3); // Posición de la cola relativa al avión
            tailPosition.applyQuaternion(airplane.quaternion); // Aplicar rotación del avión
            tailPosition.add(airplane.position); // Convertir a posición mundial
            
            // Posición de la cámara siempre detrás de la cola
            const cameraOffset = new THREE.Vector3(0, 8, -20); // Offset desde la cola
            cameraOffset.applyQuaternion(airplane.quaternion); // Rotar con el avión
            
            // Calcular posición final de la cámara
            const targetCameraPosition = tailPosition.clone().add(cameraOffset);
            
            // Movimiento suave de la cámara hacia la posición objetivo
            camera.position.lerp(targetCameraPosition, 0.15);
            
            // La cámara SIEMPRE mira específicamente a la cola del avión
            camera.lookAt(tailPosition);
            
            // REMOVIDO: Sin rotación de banking para evitar que se vea boca abajo
            // camera.rotation.z = bankingInfluence; ← Esto causaba el problema
        }

        // Configurar iluminación
        function setupLighting() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            // Luz direccional (sol)
            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.9);
            directionalLight.position.set(200, 300, 100);
            scene.add(directionalLight);
        }

        // Utilidades de optimización
        const LODManager = {
            // Niveles de detalle (en unidades de distancia)
            levels: [
                { distance: 500, name: 'high' },
                { distance: 1000, name: 'medium' },
                { distance: 2000, name: 'low' },
                { distance: Infinity, name: 'ultraLow' }
            ],
            
            // Crear un objeto con LOD
            createLODObject: function(objectsByLOD) {
                const lod = new THREE.LOD();
                
                // Ordenar los niveles de detalle por distancia
                this.levels.forEach(level => {
                    if (objectsByLOD[level.name]) {
                        lod.addLevel(objectsByLOD[level.name], level.distance);
                    }
                });
                
                return lod;
            },
            
            // Actualizar LOD basado en la posición de la cámara
            updateLODs: function(camera) {
                scene.traverse(object => {
                    if (object instanceof THREE.LOD) {
                        object.update(camera);
                    }
                });
            }
        };
        
        // Frustum Culling
        const FrustumCuller = {
            frustum: new THREE.Frustum(),
            cameraViewProjectionMatrix: new THREE.Matrix4(),
            
            // Actualizar la matriz de vista de la cámara
            updateFrustum: function(camera) {
                this.cameraViewProjectionMatrix.multiplyMatrices(
                    camera.projectionMatrix,
                    camera.matrixWorldInverse
                );
                this.frustum.setFromProjectionMatrix(this.cameraViewProjectionMatrix);
            },
            
            // Verificar si un objeto está en el frustum
            isInFrustum: function(object) {
                if (!object.geometry?.boundingSphere) {
                    // Si el objeto no tiene bounding sphere, asumir que está visible
                    return true;
                }
                
                // Crear una esfera de colisión para el objeto
                const sphere = object.geometry.boundingSphere.clone();
                sphere.applyMatrix4(object.matrixWorld);
                
                return this.frustum.intersectsSphere(sphere);
            },
            
            // Actualizar la visibilidad de los objetos basado en el frustum
            updateVisibility: function(scene) {
                scene.traverse(object => {
                    if (object instanceof THREE.Mesh || object instanceof THREE.Group) {
                        object.visible = this.isInFrustum(object);
                    }
                });
            }
        };
        
        // Control de FPS
        let lastTime = 0;
        const targetFPS = 60;
        const frameTime = 1000 / targetFPS;
        
        // Loop de animación optimizado con LOD y frustum culling
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            // Control de FPS mejorado
            const deltaTime = currentTime - lastTime;
            if (deltaTime < 1000 / targetFPS) return;
            lastTime = currentTime - (deltaTime % (1000 / targetFPS));
            
            // Actualizar física del avión
            if (airplane) {
                updateAirplane();
                
                // Actualizar cámara basada en la nueva posición del avión
                updateCamera();
                
                // Actualizar UI
                const currentSpeed = Math.sqrt(
                    velocity.x * velocity.x + 
                    velocity.y * velocity.y + 
                    velocity.z * velocity.z
                ) * 100;
                updateUI(currentSpeed);
                
                // Actualizar LODs basado en la distancia a la cámara
                LODManager.updateLODs(camera);
            }
            
            // Actualizar nubes (con optimización de rendimiento)
            updateClouds();
            
            // Actualizar frustum culling
            FrustumCuller.updateFrustum(camera);
            FrustumCuller.updateVisibility(scene);
            
            // Renderizar escena con optimizaciones
            renderer.shadowMap.needsUpdate = false; // Reducir actualizaciones de sombras
            renderer.render(scene, camera);
            
            // Actualizar estadísticas de rendimiento si están habilitadas
            if (window.stats) {
                window.stats.update();
            }
            
            // Forzar la recolección de basura periódicamente
            if (Math.random() < 0.01) {
                window.performance?.memory?.jsHeapSizeLimit > 0 && 
                window.gc?.();
            }
        }

        // Manejar redimensión de ventana
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Inicialización principal
        function init() {
            try {
                console.log('Iniciando simulador de vuelo...');
                
                // Crear escena
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x87CEEB, 800, 4000);
                
                // Crear cámara con posición inicial detrás del avión
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 6000);
                camera.position.set(0, 10, -25); // Posición inicial detrás
                
                        // Crear renderizador altamente optimizado
                const canvas = document.getElementById('canvas');
                if (!canvas) {
                    throw new Error('No se encontró el elemento canvas');
                }
                
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: false,
                    powerPreference: "high-performance",
                    stencil: false,
                    depth: true,
                    alpha: false,
                    preserveDrawingBuffer: false,
                    antialias: false
                });
                
                // Configuración avanzada del renderer
                renderer.autoClear = true;
                renderer.sortObjects = false; // Mejora el rendimiento al desactivar el ordenamiento
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x87CEEB);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Reducir calidad para mejor rendimiento
                renderer.shadowMap.enabled = false;
                renderer.outputEncoding = THREE.sRGBEncoding;
                
                // Optimización de la escena
                if (scene) {
                    scene.background = new THREE.Color(0x87CEEB);
                    scene.fog = new THREE.FogExp2(0x87CEEB, 0.0005); // Niebla más eficiente
                }
                
                // Crear elementos del mundo
                createAirplane();
                createWorld();
                setupLighting();
                
                // Inicializar sistema de joysticks
                initJoystickSystem();
                
                // Event listeners
                window.addEventListener('resize', onWindowResize);
                
                // Iniciar loop de animación
                animate();
                
                console.log('✈️ Simulador iniciado correctamente');
                console.log('📱 Controles:');
                console.log('   Joystick IZQUIERDO: Elevación (subir/bajar) y movimiento lateral');
                console.log('   Joystick DERECHO: Potencia (arriba/abajo) y dirección (izq/der)');
                
            } catch (error) {
                console.error('❌ Error en la inicialización:', error);
                
                // Mostrar mensaje de error
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(200, 0, 0, 0.9);
                    color: white;
                    padding: 25px;
                    border-radius: 15px;
                    z-index: 2000;
                    text-align: center;
                    font-family: Arial, sans-serif;
                    box-shadow: 0 8px 16px rgba(0,0,0,0.5);
                `;
                errorDiv.innerHTML = `
                    <h2>⚠️ Error del Simulador</h2>
                    <p>Hubo un problema al inicializar el juego.</p>
                    <p><strong>Solución:</strong> Recarga la página</p>
                    <button onclick="location.reload()" style="
                        background: white; 
                        color: #d00; 
                        border: none; 
                        padding: 10px 20px; 
                        border-radius: 5px; 
                        cursor: pointer; 
                        font-weight: bold;
                        margin-top: 10px;
                    ">🔄 Recargar</button>
                `;
                document.body.appendChild(errorDiv);
            }
        }

        // Iniciar cuando esté listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Prevenir comportamientos por defecto en móviles
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('touchend', (e) => e.preventDefault(), { passive: false });
    </script>
</body>
</html>